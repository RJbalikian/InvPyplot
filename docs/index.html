<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>invplot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>invplot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import csv
import pathlib 
import re
import sys

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import scipy.interpolate
import matplotlib

def autoplot(inv_file, iteration, return_dict=False, **kwargs):
    &#34;&#34;&#34;Function to run all intermedaite functions and resinv_plot to simply read and plot everything in one call.

    Parameters
    ----------
    inv_file : str or pathlib.PurePath object
        Filepath to .inv file of interest. The .inv file should be one generated from Res2DInv.
    iteration : int or list or either str {&#39;:&#39;, &#39;all&#39;}
        Integer or list of integers indicating which iteration of the .inv result to use for plotting. If list, all will be plotted separately. If &#39;:&#39; or &#39;all&#39;, will plot all iterations successively.
    return_dict : bool, optional
        Whether to return results as a dictionary, by default False
    **kwargs
        Other keyword arguments may be read into autoplot. These are read in as **kwargs to either resinv_plot() or matplotlib.pyplot.imshow via the resinv_plot function. See documentation for resinv_plot for available parameters for resinv_plot.

    Returns
    -------
    inv_dict : dict
        If return_dict set to True, Dictionary containing all input parameters and data generated along the way, including the output figures and axes

    &#34;&#34;&#34;
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)

    inv_dict = ingest_inv(inv_file, verbose=False, show_iterations=False)
    inv_dict = read_inv_data(inv_file=inv_file, inv_dict=inv_dict)

    allIterList = [&#39;:&#39;, &#39;all&#39;]
    if type(iteration) is int:
        iteration = [iteration]
    elif iteration.lower() in allIterList:
        iteration = inv_dict[&#39;iterationDF&#39;].Iteration.tolist()

    resinv_params_list = [&#39;inv_dict&#39;, &#39;colMap&#39;, &#39;cBarFormat&#39;, &#39;cBarLabel&#39;, &#39;cBarOrientation&#39;, &#39;cMin&#39;, &#39;cMax&#39;, 
                          &#39;griddedFt&#39;, &#39;griddedM&#39;, &#39;title&#39;, &#39;normType&#39;, &#39;primaryUnit&#39;, &#39;showPoints&#39;,&#39;whichTicks&#39;, 
                          &#39;figsize&#39;, &#39;dpi&#39;, &#39;reverse&#39;, &#39;tight_layout&#39;, &#39;savefig&#39;, &#39;saveformat&#39;]
    resinv_kwargs = {}
    imshow_kwargs = {}
    for key, value in kwargs.items():
        if key in resinv_params_list:
            resinv_kwargs[key] = value
        else:
            imshow_kwargs[key] = value

    iterIndList = []
    iterNoList = []
    figList = []
    axList = []

    for i in iteration:
        iterNo = i
        inv_dict[&#39;iterationNo&#39;] = iterNo
        iterInd = inv_dict[&#39;iterationDF&#39;][inv_dict[&#39;iterationDF&#39;].Iteration==i].index.tolist()[0]
        inv_dict[&#39;iterationInd&#39;] = iterInd
        inv_dict = read_inv_data_other(inv_file=inv_file, inv_dict=inv_dict, iteration_no=iterNo)
        inv_dict = read_error_data(inv_file=inv_file, inv_dict=inv_dict)
        inv_dict = get_resistivitiy_model(inv_file=inv_file, inv_dict=inv_dict)
        fig, ax = resinv_plot(inv_dict=inv_dict, imshow_kwargs=imshow_kwargs, **kwargs)

        iterIndList.append(i)
        iterNoList.append(inv_dict[&#39;iterationDF&#39;].loc[iterInd, &#39;Iteration&#39;])
        figList.append(fig)
        axList.append(ax)

    inv_dict[&#39;iterationNo&#39;] = iterIndList
    inv_dict[&#39;iterationInd&#39;] = iterNoList
    inv_dict[&#39;fig&#39;] = figList
    inv_dict[&#39;ax&#39;] = axList
    
    if return_dict:
        return inv_dict
    return

#Function that performs all the actual plotting
def resinv_plot(inv_dict, colMap=&#39;nipy_spectral&#39;, cBarFormat =&#39;%3.0f&#39;, cBarLabel=&#39;Resistivity (ohm-m)&#39;, cBarOrientation=&#39;horizontal&#39;, cMin=None, cMax=None, griddedFt=[False,False], griddedM=[False,False], title=None, normType=&#39;log&#39;, primaryUnit=&#39;m&#39;, showPoints=False,whichTicks=&#39;major&#39;, figsize=None, dpi=None, reverse=False, tight_layout=True, savefig=False, saveformat=&#39;png&#39;, imshow_kwargs=None, **kwargs):
    &#34;&#34;&#34;Function to pull everything together and plot it nicely.

    It is recommended to use the autoplot function rather than resinv_plot directly, since using autoplot() incorporates all the setup needed to create the input dictionary keys/values correctly.

    Parameters
    ----------
    inv_dict : dict
        Dictionary of inversion results generated from previous steps
    colMap : str, optional
        Colormap, any acceptable from matplotlib, by default &#39;nipy_spectral&#39;
    cBarFormat : str, optional
        Format string for colorbar tick labels, by default &#39;%3.0f&#39;
    cBarLabel : str, optional
        Colorbar label, by default &#39;Resistivity (ohm-m)&#39;
    cBarOrientation : str {&#39;horizonta&#39;, &#39;vertical&#39;}, optional
        Orientation of the colorbar, by default &#39;horizontal&#39;
    cMin : float, optional
        Minimum of colorbar/colormap, by default None, which uses the minimum value of the dataset.
    cMax : float, optional
        Maximum of colorbar/colormap, by default None, which uses the maximum value of the dataset.
    griddedFt : list, optional
        Whether to show gridlines on the feet ticks, first position is x, second position is y, by default [False,False]
    griddedM : list, optional
        Whether to show gridlines on the meter tickes, first position is x, second posistion is y, by default [False,False]
    title : str, optional
        String to show as the title, if desired to set manually, by default None, which shows the filename as the title
    normType : str {&#39;log&#39;, &#39;linear&#39;}, optional
        Normalization type, by default &#39;log&#39;. Determines whether matplotlib.colors.LogNorm or matplotlib.colors.Normalize is used for colormap.
    primaryUnit : str {&#39;m&#39;, &#39;ft&#39;}, optional
        Whether to display meters or feet as primary unit (this determines which unit is larger on the axis and is on the left and top), by default &#39;m&#39;
    showPoints : bool, optional
        Whether to show the datapoints used for interpolation, by default False
    whichTicks : str {&#39;major&#39;, &#39;minor&#39;, &#39;both&#39;}, optional
        If griddedFt or griddedM has any True, this determines whether major, minor, or both gridlines are used; by default &#39;major&#39;.
    figsize : tuple, optional
        Tuple (width, height) of the figsize, read into plt.rcParams[&#39;figure.figsize&#39;], by default None.
    dpi : int or float, optional
        Resolution (dots per square inch) of final figure, read into plt.rcParams[&#39;figure.dpi&#39;], by default None.
    reverse : bool, optional
        Whether to display the data in reverse (flipped along x) of what is read into from .inv file, by default False
    tight_layout : bool, optional
        If true, calls fig.tight_layout(). Otherwise, tries to maximize space on the figure using plt.subplots_adjust, by default True
    savefig : bool, optional
        If False, will not save figure. Otherwise, calls plt.savefig() and the value of this parameter will be used as the output filepath, by default False.
    saveformat : str, optional
        Read into plt.savefig(format) paramater, by default &#39;png&#39;.

    Returns
    -------
    dict
        Returns existing inv_dict input, but with added keys of [&#39;fig&#39;] and [&#39;ax&#39;] containing a list of the fig and ax objects (list, since multiple iterations can be done at once)
    &#34;&#34;&#34;
    if title is None:
        title = inv_dict[&#39;inv_file_Path&#39;].stem
    
    if &#39;figure.dpi&#39; not in list(inv_dict.keys()):
        inv_dict[&#39;figure.dpi&#39;] = 250
    if &#39;figure.figsize&#39; not in list(inv_dict.keys()):
        inv_dict[&#39;figure.figsize&#39;] = (12,5)

    x = inv_dict[&#39;resistModelDF&#39;][&#39;x&#39;].copy()
    z = inv_dict[&#39;resistModelDF&#39;][&#39;zElev&#39;].copy()
    v = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].copy()

    if figsize is None:
        plt.rcParams[&#39;figure.figsize&#39;] = inv_dict[&#39;figure.figsize&#39;]
    else:
        inv_dict[&#39;figure.figsize&#39;] = figsize
        plt.rcParams[&#39;figure.figsize&#39;] = figsize

    if dpi is None:
        plt.rcParams[&#39;figure.dpi&#39;] = inv_dict[&#39;figure.dpi&#39;]
    else:
        inv_dict[&#39;figure.dpi&#39;] = dpi
        plt.rcParams[&#39;figure.dpi&#39;] = dpi
    
    maxXDist = max(np.float_(inv_dict[&#39;electrodes&#39;]))

    if cMin is None:
        cMin = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].min()
    if cMax is None:
        cMax = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].max()
    

    for i in enumerate(v):
        v[i[0]] = abs(float(i[1]))

    xi, zi = np.linspace(min(x), max(x), int(max(x))), np.linspace(min(z), max(z), int(max(z)))
    xi, zi = np.meshgrid(xi, zi)

    vi = scipy.interpolate.griddata((x, z), v, (xi, zi))#, method=&#39;linear&#39;)

    ptSize = round(100 / maxXDist * 35, 1)

    fig, axes = plt.subplots(1)
    cmap = matplotlib.cm.binary
    my_cmap = cmap(np.arange(cmap.N))
    my_cmap[:,-1] = np.linspace(0,1,cmap.N)
    my_cmap = matplotlib.colors.ListedColormap(my_cmap)

    vmax98 = np.percentile(v, 98)
    vmin2 = np.percentile(v, 2)
    minx = min(x)
    maxx = max(x)
    minz = min(z)
    maxz = max(z)

    vmax = cMax
    vmin = cMin

    #if cMax &gt;= resistModelDF[&#39;Data&#39;].max():
    #  vmax = vmax98
    #else:
    #  vmax = cMax
    #if cMin &lt;= resistModelDF[&#39;Data&#39;].min():
    #  vmin = vmin2
    #else:
    #  vmin = cMin
    #cbarTicks = np.arange(np.round(vmin,-1),np.round(vmax-1)+1,10) 

    arStep = np.round((vmax-vmin)/10,-1)
    cbarTicks = np.arange(np.round(vmin, -1), np.ceil(vmax/10)*10,arStep)

    #Get default values or kwargs, depending on if kwargs have been used
    if &#39;norm&#39; in imshow_kwargs.keys():
        norm = imshow_kwargs[&#39;norm&#39;]
    else:
        if normType==&#39;log&#39;:
            if vmin &lt;= 0:
                vmin = 0.1
            norm = matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax)
            #cBarFormat = &#39;%.1e&#39;
            #cbarTicks = np.logspace(np.log10(vmin),np.log10(vmax),num=10)
        else:
            norm = matplotlib.colors.Normalize(vmin = vmin, vmax = vmax)

    #im = self.axes.imshow(vi, vmin=vmin, vmax=vmax, origin=&#39;lower&#39;,
    if &#39;extent&#39; in imshow_kwargs.keys():
        extent = imshow_kwargs[&#39;extent&#39;]
        imshow_kwargs.pop(&#39;extent&#39;, None)
    else:
        extent = [minx, maxx, minz, maxz]
        
    if &#39;aspect&#39; in imshow_kwargs.keys():
        aspect = imshow_kwargs[&#39;aspect&#39;]
        imshow_kwargs.pop(&#39;aspect&#39;, None)
    else:
        aspect = &#39;auto&#39;
        
    if &#39;cmap&#39; in imshow_kwargs.keys():
        cmap = imshow_kwargs[&#39;cmap&#39;]
        imshow_kwargs.pop(&#39;cmap&#39;, None)
    else:
        cmap=colMap   
        
    if &#39;interpolation&#39; in imshow_kwargs.keys():
        interp = imshow_kwargs[&#39;interpolation&#39;]
        imshow_kwargs.pop(&#39;interpolation&#39;, None)
    else:
        interp=&#39;spline36&#39;   
    
    im = axes.imshow(vi, origin=&#39;lower&#39;,
                extent=extent,
                aspect=aspect,
                cmap =cmap,
                norm = norm,
                interpolation=interp, **imshow_kwargs)
    f, a = __plot_pretty(inv_dict, x,z,v,fig=fig,im=im,ax=axes,colMap=colMap,cMin=cMin,cMax=cMax, 
                       gridM=griddedM, gridFt=griddedFt, primaryUnit=primaryUnit, t=title, tight_layout=tight_layout,
                       cbarTicks=cbarTicks,cBarFormat=cBarFormat,cBarLabel=cBarLabel,cBarOrient=cBarOrientation,
                       showPoints=showPoints, norm=norm, whichTicks=whichTicks, reverse=reverse)

    plt.show(fig)
    if savefig is not False:
        plt.savefig(savefig, format=saveformat, facecolor=&#39;white&#39;)

    plt.close(f)
    return f, a

#Function to ingest inv file and find key information for later
def ingest_inv(inv_file, verbose=True, show_iterations=True):
    &#34;&#34;&#34;Function to ingest inversion file and get key points (row numbers) in the file

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        The res2Dinv .inv file to work with.
    verbose : bool, default=True
        Whether to print results to terminal. Here, prints a pandas dataframe with information about iterations.
    show_iterations : bool, default=True
        Whether to show a matplotlib plot with the iteration on x axis and percent error on y axis.

    Returns
    -------
    inv_dict : dict
        Dictionary containing the important locations in the file
    &#34;&#34;&#34;
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)
    
    fileHeader = []
    iterationStartRowList = []
    layerRowList = []
    layerDepths = []
    noLayerRow = -1
    blockRow = -1
    layerRow = -1
    layerInfoRow = -1
    resistDF = pd.DataFrame()
    dataList = []
    noPoints = []
    calcResistivityRowList = []
    refResistRow=-1
    topoDataRow = -1
    iterationsInfoRow = -1

    with open(str(inv_file)) as datafile: 
        filereader = csv.reader(datafile)
        for row in enumerate(filereader):
            startLayer = 0
            endLayer = 0
            lay = -1
            #print(row[0])
            if row[0] &lt;= 8:
               
                if len(row[1])&gt;1:
                    fileHeader.append(row[1][0]+&#39;, &#39;+row[1][1])
                    continue
                else:
                    fileHeader.append(row[1][0].strip())
                    continue
                
            if &#39;NUMBER OF LAYERS&#39; in str(row[1]):
                noLayerRow = row[0]+1
                continue
            if row[0] == noLayerRow:
                noLayers = int(row[1][0])
                layerList = np.linspace(1,noLayers, noLayers)
                continue
            
            if &#39;NUMBER OF BLOCKS&#39; in str(row[1]):
                blockRow = row[0]+1
                continue
            if row[0]==blockRow:
                noBlocks = int(row[1][0])
                continue

            if &#39;ITERATION&#39; in str(row[1]):
                iterationStartRowList.append(row[0]) #Add row of iteration to iterationStartRowList
                continue

            if &#39;LAYER &#39; in str(row[1]):
                iterInd = len(iterationStartRowList)-1
                if iterInd &gt; len(layerRowList)-1:
                    layerRowList.append([row[0]])
                else:
                    layerRowList[iterInd].append(row[0])
                layerInfoRow = row[0]+1
                continue
            if row[0]==layerInfoRow:
                noPoints.append(int(row[1][0].strip()))
                layerDepths.append(row[1][1].strip())
                continue
            
            if &#39;CALCULATED APPARENT RESISTIVITY&#39; in str(row[1]):
                calcResistivityRowList.append(row[0])
                continue
            
            if &#39;Reference resistivity is&#39; in str(row[1]):
                refResistRow = row[0]+1 
                continue
            
            if row[0]==refResistRow:
                refResist = float(row[1][0].strip())
                continue
            
            if &#39;TOPOGRAPHICAL DATA&#39; in str(row[1]):
                topoDataRow = row[0]
                continue
            if row[0]==topoDataRow+2:
                noTopoPts = int(row[1][0].strip())
                continue

            if &#39;COORDINATES FOR ELECTRODES&#39; in str(row[1]):
                electrodeCoordsRow = row[0]
                continue

            if &#39;Shift matrix&#39; in str(row[1]):
                shiftMatrixRow = row[0]
                continue

            if &#39;Blocks sensitivity and uncertainity values (with smoothness constrain)&#39; in str(row[1]):
                sensAndUncertainRow = row[0]
                continue

            if &#39;Error Distribution&#39; in str(row[1]):
                errorDistRow = row[0] #no of data points
                continue

            if &#39;Total Time&#39; in str(row[1]):
                iterationsInfoRow=row[0]
                iterDataList = []
                continue
            
            if iterationsInfoRow &gt; 1:
                if row[1] == []:
                    print(&#39;   &#39;)
                    noIterations = row[0]-iterationsInfoRow-1
                    break
                iterDataList.append(row[1][0].split())

    layerDepths = layerDepths[0:noLayers]
    layerDepths[noLayers-1] = float(layerDepths[(noLayers-2)])+(float(layerDepths[noLayers-2])-float(layerDepths[noLayers-3]))
    layerDepths = [float(x) for x in layerDepths]

    noPoints = noPoints[0:noLayers]

    keyList=[&#39;Name&#39;, &#39;NomElectrodeSpacing&#39;, &#39;ArrayCode&#39;, &#39;ProtocolCode&#39;, &#39;MeasureHeader&#39;, &#39;MeasureType&#39;, &#39;NoDataPoints&#39;,&#39;DistanceType&#39;,&#39;FinalFlag&#39;]

    global fileHeaderDict
    fileHeaderDict = dict(zip(keyList, fileHeader))
    noDataPoints = int(fileHeaderDict[&#39;NoDataPoints&#39;])
    iterationDF = pd.DataFrame(iterDataList, columns=[&#39;Iteration&#39;,  &#39;Time for this iteration&#39;, &#39;Total Time&#39;, &#39;%AbsError&#39;])
    iterationDF = iterationDF.apply(pd.to_numeric)

    if verbose:
        print(iterationDF)
    if show_iterations:
        fig1, ax1 = plt.subplots(1)
        iterationDF.plot(&#39;Iteration&#39;,&#39;%AbsError&#39;,figsize=(3,3), ax=ax1, c=&#39;k&#39;)
        iterationDF.plot(&#39;Iteration&#39;,&#39;%AbsError&#39;,figsize=(3,3),kind=&#39;scatter&#39;, ax=ax1, c=&#39;k&#39;)
        ax1.set_title(inv_file.stem)
        ax1.set_xticks(np.arange(0,iterationDF[&#39;Iteration&#39;].max()+1))
        ax1.get_legend().remove()
        plt.show(fig1)

    inv_dict = {
        &#39;inv_file_Path&#39;:inv_file,
        &#39;fileHeader&#39;:fileHeader,
        &#39;iterationStartRowList&#39;:iterationStartRowList,
        &#39;layerRowList&#39;:layerRowList, 
        &#39;layerDepths&#39;:layerDepths,
        &#39;noLayerRow&#39;:noLayerRow,
        &#39;blockRow&#39;:blockRow ,
        &#39;layerRow&#39;:layerRow ,
        &#39;layerInfoRow&#39;:layerInfoRow ,
        &#39;resistDF&#39;:resistDF,
        &#39;dataList&#39;:dataList,
        &#39;noPoints&#39;:noPoints,
        &#39;calcResistivityRowList&#39;:calcResistivityRowList ,
        &#39;refResistRow&#39;:refResistRow,
        &#39;topoDataRow&#39;:topoDataRow,
        &#39;iterationsInfoRow&#39;:iterationsInfoRow,
        &#39;iterationDF&#39;:iterationDF,
        &#39;noIterations&#39;:noIterations,
        &#39;noDataPoints&#39;:noDataPoints,
        &#39;shiftMatrixRow&#39;:shiftMatrixRow,
        &#39;electrodeCoordsRow&#39;:electrodeCoordsRow,
        &#39;noTopoPts&#39;:noTopoPts,
        &#39;sensAndUncertainRow&#39;:sensAndUncertainRow,
        &#39;noModelBlocks&#39;:[],
        &#39;errorDistRow&#39;:errorDistRow,
        &#39;fileHeaderDict&#39;:fileHeaderDict}
    
    return inv_dict

#Input Data
def read_inv_data(inv_file, inv_dict, startRow=9):
    &#34;&#34;&#34;Function to do initial read of .inv file. 
    
    This data does not change with iteration, as in later function. This function should be readafter ingest_inv, using the output from that as inv_dict.
     
    

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath of .inv file
    inv_dict : dict
        Dictionary (output from ingest_inv) containing information about where data is located in the .inv file
    startRow : int, optional
        Where to start the read. This is, by default 9, which works well for .inv files tested.

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    noDataPoints = inv_dict[&#39;noDataPoints&#39;]
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)

    import csv
    with open(inv_file) as datafile: 
        filereader = csv.reader(datafile)
        start = 0
        inDataList = []
        for row in enumerate(filereader):
            if row[0] &lt; startRow:
                continue
            elif row[0] &lt; startRow+noDataPoints:
                inDataList.append(re.sub(&#39;\s+&#39;,&#39; &#39;,row[1][0]).split(&#39; &#39;))
            else:
                break
    inDF = pd.DataFrame(inDataList)
    if startRow == 9:
        inDF.drop([0],inplace=True,axis=1)
    inDF.astype(np.float64)
    inDF.columns=[&#39;NoElectrodes&#39;, &#39;A(x)&#39;, &#39;A(z)&#39;, &#39;B(x)&#39;, &#39;B(z)&#39;, &#39;M(x)&#39;, &#39;M(z)&#39;, &#39;N(x)&#39;, &#39;N(z)&#39;, &#39;Data&#39;]
    inv_dict[&#39;resistDF&#39;]  = inDF
    return inv_dict

#Read other important inversion data
def read_inv_data_other(inv_file, inv_dict, iteration_no=None):
    &#34;&#34;&#34;Function to read inversion data. 

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest.
    inv_dict : dict
        Dictionary contianing outputs from ingest_inv and read_in_data.
    iteration_no : int
        Iteration number of interest.

    Returns
    -------
    dict
        Dictionary with more information appended to input dictionary
    &#34;&#34;&#34;
    if iteration_no is None:
        print(&#39;Please run read_inv_data_other again and specify iteration by setting iteration_no parameter equal to integer.&#39;)
        return
    #Extract needed variables from dict
    iterationInd = inv_dict[&#39;iterationDF&#39;][inv_dict[&#39;iterationDF&#39;].Iteration==iteration_no].index.tolist()[0]
    inv_dict[&#39;iterationNo&#39;] = iteration_no
    inv_dict[&#39;iterationInd&#39;] = iterationInd


    invDF = inv_dict[&#39;resistDF&#39;]
    layerRowList = inv_dict[&#39;layerRowList&#39;]
    noPoints = inv_dict[&#39;noPoints&#39;]
    layerDepths = inv_dict[&#39;layerDepths&#39;]
    shiftMatrixRow = inv_dict[&#39;shiftMatrixRow&#39;]
    electrodeCoordsRow = inv_dict[&#39;electrodeCoordsRow&#39;]
    topoDataRow = inv_dict[&#39;topoDataRow&#39;]
    noTopoPts = inv_dict[&#39;noTopoPts&#39;]
    sensAndUncertainRow = inv_dict[&#39;sensAndUncertainRow&#39;]

    #Get Electrodes
    electrodes= pd.concat([invDF[&#39;A(x)&#39;],invDF[&#39;B(x)&#39;], invDF[&#39;M(x)&#39;], invDF[&#39;B(x)&#39;], invDF[&#39;N(x)&#39;]],ignore_index=True)
    electrodes.reset_index(inplace=True, drop=True)
    electrodes = electrodes.unique()
    inv_dict[&#39;electrodes&#39;] = electrodes

    #ElectrodeCoordinates
    noModelElects = shiftMatrixRow-electrodeCoordsRow-1
    electrodeCoordsDF = pd.read_table(inv_file,skiprows=electrodeCoordsRow,nrows=noModelElects, sep=&#39;\s+&#39;)
    electrodeCoordsDF.dropna(axis=1,inplace=True)
    electrodeCoordsDF.columns=[&#39;xDist&#39;,&#39;RelElevation&#39;]
    electrodeCoordsDF[&#39;ElectrodeNo&#39;] = electrodeCoordsDF.index+1
    inv_dict[&#39;electrodeCoordsDF&#39;] = electrodeCoordsDF

    #Topographical Data
    topoDF = pd.read_table(inv_file,skiprows=topoDataRow+2,nrows=noTopoPts, sep=&#39;\s+&#39;)
    topoDF.reset_index(inplace=True)
    topoDF.columns=[&#39;xDist&#39;,&#39;Elevation&#39;]
    topoDF[&#39;ElectrodeNo&#39;] = topoDF.index+1
    inv_dict[&#39;topoDF&#39;] = topoDF

    #Resistivity Model
    resistModelDF = pd.DataFrame()
    for r in enumerate(layerRowList[iterationInd]):
        layerDepth = layerDepths[r[0]]
        noPtsInLyr = noPoints[r[0]]
        currDF = pd.read_table(inv_file,skiprows=r[1]+1, nrows=noPtsInLyr,sep=&#39;,&#39;)
        currDF.columns=[&#39;ElectrodeNo&#39;,&#39;Data&#39;]
        currDF[&#39;z&#39;] = layerDepth
        resistModelDF= pd.concat([resistModelDF,currDF],ignore_index=True).copy()
    resistModelDF.reset_index(inplace=True, drop=True)
    noModelBlocks=resistModelDF.shape[0]
    inv_dict[&#39;resistModelDF&#39;] = resistModelDF
    inv_dict[&#39;noModelBlocks&#39;] = noModelBlocks

    #Shift Matrix
    shiftMatrixDF = pd.read_table(inv_file,skiprows=shiftMatrixRow+1,nrows=noModelElects, sep=&#39;\s+&#39;,header=None,index_col=0)
    shiftMatrixDF.dropna(axis=1,inplace=True)
    for c in shiftMatrixDF:
        shiftMatrixDF.rename(columns={c:&#39;Layer&#39;+str(int(c)-1)},inplace=True)
    inv_dict[&#39;shiftMatrixDF&#39;] = shiftMatrixDF

    #Sensitivity
    sensDF = pd.read_table(inv_file,skiprows=sensAndUncertainRow+3,nrows=noModelBlocks, sep=&#39;\s+&#39;,header=None,index_col=0)
    sensDF.dropna(axis=1,inplace=True)
    sensDF.reset_index(inplace=True)
    sensDF.columns=[&#39;BlockNo&#39;,&#39;Sensitivity&#39;, &#39;%ApproxUncertainty&#39;]
    inv_dict[&#39;sensDF&#39;] = sensDF

    return inv_dict

#Error Distribution
def read_error_data(inv_file, inv_dict):
    &#34;&#34;&#34;Function to read data pertaining to model error

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest
    inv_dict : dict 
        Dictionary containing cumulative output from ingest_inv, read_inv_data, and read_inv_data_other

    Returns
    -------
    dict
        Ouptput dictionary containing all information from read_error_data and previous functions.
    &#34;&#34;&#34;
    import csv
    noDataPoints = inv_dict[&#39;noDataPoints&#39;]
    startRow = inv_dict[&#39;errorDistRow&#39;]+1

    with open(inv_file) as datafile: 
        filereader = csv.reader(datafile)
        inDataList = []
        for row in enumerate(filereader):
            if row[0] &lt; startRow:
                continue
            elif row[0] &lt; startRow+noDataPoints:
                newrow = row[1]
                newrow.append(newrow[4][8:])
                newrow[4] = newrow[4][0:8]
                newrow = [x.strip() for x in newrow]
                inDataList.append(newrow)
            else:
                break
    inDF = pd.DataFrame(inDataList)
    inv_dict[&#39;errDistDF&#39;] = inDF

    errDistDF = inv_dict[&#39;errDistDF&#39;]

    colList=[&#39;xDist?&#39;,&#39;nFactor?&#39;,&#39;Measure1&#39;,&#39;Measure2&#39;,&#39;PercentError&#39;,&#39;MoreStacks&#39;,&#39;AvgMeasure&#39;]
    for i in range(0,5):
        errDistDF[i]=errDistDF[i].astype(np.float64)
        errDistDF.rename(columns={i:colList[i]},inplace=True)
    errDistDF[&#39;AvgMeasure&#39;] = (errDistDF[&#39;Measure1&#39;]+errDistDF[&#39;Measure2&#39;])/2
    inv_dict[&#39;errDistDF&#39;] = errDistDF
    return inv_dict

#Interpolate between two points, simple
def map_diff(xIn, x1,x2,y1,y2):
    &#34;&#34;&#34;Simple, linear interpolation between two points

    Parameters
    ----------
    xIn : float, int, or numeric
        X Location at which y-value is desired. This should fall between (or be equal to) x1 and x2
    x1 : float, int, or numeric
        Initial X location, with known y-value y1 
    x2 : float, int, or numeric
        Second X location, with known y-value y2
    y1 : float, int, or numeric
        Known y-value at x1
    y2 : float, int, or numeric
        Known y-value at x2

    Returns
    -------
    float
        Y-value that is proportionally scaled based on the xIn relative distance to x1 and x2
    &#34;&#34;&#34;
    if x1==xIn:
        yOut=y1
    elif x2==xIn:
        yOut = y2
    else:
        totXDiff = x2-x1
        percXDiff = (xIn-x1)/totXDiff
        totYDiff = y2-y1
        yOut = y1 + totYDiff*percXDiff
    return yOut

#Function to get resistivity model as pandas dataframe
def get_resistivitiy_model(inv_file, inv_dict):
    &#34;&#34;&#34;Function to read the resistivity model, given the iteration of interest.

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest
    inv_dict : dict
        Dictionary containing cumulative output from invest_inv, read_inv_data, read_inv_data_other, and read_error_data.

    Returns
    -------
    dict
        Dictionary with resistivity model contained in new key:value pair of inv_dict
    &#34;&#34;&#34;
    resistModelDF = pd.DataFrame()
    layerRowList= inv_dict[&#39;layerRowList&#39;]
    iterationInd= inv_dict[&#39;iterationInd&#39;]
    layerDepths= inv_dict[&#39;layerDepths&#39;]
    noPoints= inv_dict[&#39;noPoints&#39;]
    electrodeCoordsDF= inv_dict[&#39;electrodeCoordsDF&#39;]
    topoDF= inv_dict[&#39;topoDF&#39;]

    for r in enumerate(layerRowList[iterationInd]):
        layerDepth = layerDepths[r[0]]
        noPtsInLyr = noPoints[r[0]]
        currDF = pd.read_table(inv_file, skiprows=r[1]+1, nrows=noPtsInLyr,sep=&#39;,&#39;)
        currDF.iloc[currDF.shape[0]-1,1] =  currDF.iloc[currDF.shape[0]-1,0]
        currDF.iloc[currDF.shape[0]-1,0] = currDF.iloc[currDF.shape[0]-2,0]+1
        currDF.columns=[&#39;ElectrodeNo&#39;,&#39;Data&#39;]
        currDF[&#39;zDepth&#39;] = layerDepth

        for i in currDF.index:
            lowerElecNo = currDF.loc[i,&#39;ElectrodeNo&#39;]#-1
            elecInd = electrodeCoordsDF.loc[electrodeCoordsDF[&#39;ElectrodeNo&#39;]==lowerElecNo].index.values[0]
            currDF.loc[i,&#39;x&#39;] = (electrodeCoordsDF.loc[elecInd,&#39;xDist&#39;] + electrodeCoordsDF.loc[elecInd+1,&#39;xDist&#39;])/2
            for xT in enumerate(topoDF[&#39;xDist&#39;]):
                if xT[1] &lt; currDF.loc[i,&#39;x&#39;]:
                    continue
                else:
                    topoX1 = topoDF.loc[xT[0]-1,&#39;xDist&#39;]
                    topoX2 = topoDF.loc[xT[0],&#39;xDist&#39;]
                    topoZ1 = topoDF.loc[xT[0]-1,&#39;Elevation&#39;]
                    topoZ2 = topoDF.loc[xT[0],&#39;Elevation&#39;]
                    break
            currDF.loc[i,&#39;zElev&#39;] = map_diff(currDF.loc[i,&#39;x&#39;],topoX1, topoX2, topoZ1, topoZ2)-currDF.loc[i,&#39;zDepth&#39;]
        if r[0] == 0:
            surfDF = currDF.copy()
            surfDF[&#39;zElev&#39;] = surfDF.loc[:,&#39;zElev&#39;]+surfDF.loc[:,&#39;zDepth&#39;]
            surfDF[&#39;zDepth&#39;] = 0
            resistModelDF = pd.concat([resistModelDF, surfDF], ignore_index=True)
            resistModelDF.reset_index(inplace=True, drop=True)
        resistModelDF = pd.concat([resistModelDF, currDF], ignore_index=True)
        resistModelDF.reset_index(inplace=True, drop=True)
    inv_dict[&#39;resistModelDF&#39;] = resistModelDF
    return inv_dict

#Helper function for __plot_pretty
def __label_plot(fig, ax, gridM, gridFt, whichTicks, pUnit, pUnitXLocs, pUnitYLocs, pUnitXLabels,pUnitYLabels, sUnit, sUnitXLocs, sUnitYLocs, sUnitXLabels, sUnitYLabels, xLims, yLims, t):
    &#34;&#34;&#34;See __plot_pretty, as all input parameters are derived from there&#34;&#34;&#34;
    #matplotlib.rc(&#39;font&#39;, family=&#39;sans-serif&#39;)   
    #matplotlib.rc(&#39;font&#39;, serif=&#39;Helvetica&#39;) 
    #matplotlib.rc(&#39;text&#39;, usetex=&#39;false&#39;)   
    #fontName = {&#39;fontname&#39;:&#39;Helvetica&#39;}
    
    plt.title(t)
    ax.set_title(t, fontsize=20)
    ax.set_xlabel(&#39;Distance [&#39;+sUnit+&#39;]&#39;, fontsize = 12)
    ax.set_ylabel(&#39;Elevation [&#39;+pUnit+&#39;]&#39;, fontsize = 14)
    ax.set_xticks(sUnitXLocs)
    ax.set_yticks(pUnitYLocs)
    ax.set_xticklabels(sUnitXLabels,fontsize=12)
    ax.set_yticklabels(pUnitYLabels,fontsize=12)
    ax.set_yticks(pUnitYLocs)
    ax.set_ylim(yLims)
    ax.set_xlim(xLims)
    ax.minorticks_on()

    ax2=ax.twiny()
    ax2.set_xticks(pUnitXLocs)
    ax2.set_xticklabels(pUnitXLabels,fontdict={&#39;fontsize&#39;:14})
    ax2.set_xlabel(&#39;Distance [&#39;+pUnit+&#39;]&#39;,fontsize=14)
    ax2.minorticks_on()
    ax2.set_xlim(xLims)

    ax3=ax2.twinx()
    ax3.set_yticks(sUnitYLocs)
    ax3.set_yticklabels(sUnitYLabels,fontdict={&#39;fontsize&#39;:10})
    ax3.set_ylim(yLims)
    ax3.set_ylabel(&#39;Elevation [&#39;+sUnit+&#39;]&#39;,fontsize=14, rotation=270, labelpad = 20)
    ax3.minorticks_on()
    

    if pUnit==&#39;m&#39;:
        if gridM[0]:
           ax2.grid(axis=&#39;x&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridM[1]:
            ax.grid(axis=&#39;y&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridFt[0]:
            ax.grid(axis=&#39;x&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridFt[1]:
            ax3.grid(axis=&#39;y&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
    else:
        if gridFt[0]:
            ax2.grid(axis=&#39;x&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridFt[1]:
            ax.grid(axis=&#39;y&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridM[0]:
            ax.grid(axis=&#39;x&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)
        if gridM[1]:
            ax3.grid(axis=&#39;y&#39;,alpha=0.5, c=&#39;k&#39;, which=whichTicks)

#Helper function for resinv_plot
def __plot_pretty(inv_dict, x,z,v,im,cbarTicks,fig,ax, colMap=&#39;jet&#39;,cMin=None,cMax=None, gridFt=[False,False], gridM=[False,False], t=&#39;&#39;, primaryUnit=&#39;m&#39;, tight_layout=True, cBarOrient=&#39;vertical&#39;, cBarFormat =&#39;%3.0f&#39;,cBarLabel =&#39;Resistivity (ohm-m)&#39;, showPoints=False, norm=0, whichTicks=&#39;major&#39;, reverse=False):
    &#34;&#34;&#34;Helper function for resinv_plot, parameters derived from there.&#34;&#34;&#34;

    topoDF = inv_dict[&#39;topoDF&#39;]
    if cMin is None:
        cMin = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].min()
    if cMax is None:
        cMax = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].max()
    
    plt.rcParams[&#34;figure.dpi&#34;] = 300  
    plt.rcParams[&#39;xtick.bottom&#39;] = plt.rcParams[&#39;xtick.labelbottom&#39;] = False
    plt.rcParams[&#39;xtick.top&#39;] = plt.rcParams[&#39;xtick.labeltop&#39;] = plt.rcParams[&#34;xtick.top&#34;] = True
    plt.sca(ax)
    

    vmax90 = np.percentile(v, 90)
    vmin2 = np.percentile(v, 2)
    vmax = v.max()
    vmin = v.min()
    minx = topoDF[&#39;xDist&#39;].min()
    maxx = topoDF[&#39;xDist&#39;].max()
    minz = min(z)
    maxz = max(z)

    #xlocsM = ax.get_xticks()
    if maxx&gt;800:
        xlocsM = np.arange(minx,maxx+1,100)
        if max(xlocsM) &lt; maxx:
            xlocsM = np.arange(minx,maxx+101,100)
    else:
        xlocsM = np.arange(minx,maxx+1,50)
        if max(xlocsM) &lt; maxx:
            xlocsM = np.arange(minx,maxx+51,50)

    xlabelsM = [str(int(x)) for x in xlocsM]
    xlocsFt = np.uint16(xlocsM*3.2808399)
    xlabelsFt = [str(int(x)) for x in xlocsFt]

    minFtxLoc = xlocsFt[0]
    maxFtxLoc = xlocsFt[-1]
    xLabelsFtEven = np.arange(np.round(minFtxLoc,-1), np.round(maxFtxLoc,-1), 100)

    if np.round(maxFtxLoc,-1) &lt; maxFtxLoc:
        xLabelsFtEven=np.insert(xLabelsFtEven, len(xLabelsFtEven),np.round(maxFtxLoc,-2))
        xLabelsFtEven=np.insert(xLabelsFtEven, len(xLabelsFtEven),np.round(maxFtxLoc,-2)+100)
    xLocs_FTinM = xLabelsFtEven / 3.2808399

    if np.ceil(maxz)&gt;np.round(maxz,-1):
        zEnd = np.round(maxz,-1)+11
    else:
        zEnd = np.round(maxz,-1)+1
    
    ylocsM = np.arange(np.round(minz,-1),zEnd,10)
    ylabelsM = [str(x) for x in ylocsM]
    yLabelsFt = np.uint16(ylocsM*3.2808399)

    minFtyLabel = yLabelsFt.min()
    maxFtyLabel = yLabelsFt.max()
    yLabelsFtEven = np.arange(0, np.round(maxFtyLabel,-1), 20)
    

    if np.round(maxFtyLabel,-1) &lt; maxFtyLabel:
        yLabelsFtEven=np.insert(yLabelsFtEven, len(yLabelsFtEven),yLabelsFtEven[-1]+20)
    yLocs_FTinM = yLabelsFtEven / 3.2808399

    yLimsM = [ylocsM[1],maxz+3]
    yLimsM = [minz,maxz+3]
    yLimsFt = [np.round(yLimsM[0]*3.2808399, 0), np.round(yLimsM[1]*3.2808399, 0)]

    ax.fill_between(topoDF[&#39;xDist&#39;],topoDF[&#39;Elevation&#39;],topoDF[&#39;Elevation&#39;]+10,color=&#39;w&#39;)
    ax.plot(topoDF[&#39;xDist&#39;],topoDF[&#39;Elevation&#39;],color=&#39;k&#39;,linewidth=1)
    ax.scatter(topoDF[&#39;xDist&#39;],topoDF[&#39;Elevation&#39;],marker=&#39;v&#39;,edgecolors=&#39;w&#39;,color=&#39;k&#39;,s=30)
    if showPoints:
        plt.scatter(x,z, c=v, marker=&#39;.&#39;, cmap=&#39;nipy_spectral&#39;, norm=norm)

    xLimsM = [minx,maxx]
    xLimsFt = [np.round(xLimsM[0]*3.2808399, 0), np.round(xLimsM[1]*3.2808399, 0)]
    if reverse:
        xLimsM.reverse()
        xLimsFt.reverse()
        #xlocsM=np.flip(xlocsM)
        #xLocs_FTinM=np.flip(xLocs_FTinM)


    if primaryUnit in [&#39;m&#39;, &#39;meters&#39;, &#39;meter&#39;, &#39;metres&#39;, &#39;metre&#39;, &#39;metric&#39;]:
        pUnit = &#39;m&#39;
        pUnitXLocs = xlocsM
        pUnitYLocs = ylocsM
        pUnitXLabels = xlabelsM
        pUnitYLabels = ylabelsM

        sUnit = &#39;ft&#39;
        sUnitXLocs = xLocs_FTinM
        sUnitYLocs = yLocs_FTinM
        sUnitXLabels = xLabelsFtEven
        sUnitYLabels = yLabelsFtEven
        __label_plot(fig, ax, gridM, gridFt, whichTicks, primaryUnit, pUnitXLocs, pUnitYLocs, pUnitXLabels,pUnitYLabels, sUnit, sUnitXLocs, sUnitYLocs, sUnitXLabels, sUnitYLabels, xLims=xLimsM, yLims=yLimsM, t=t)
    
    elif primaryUnit in [&#39;f&#39;, &#39;ft&#39;, &#39;feet&#39;, &#39;foot&#39;, &#39;US&#39;]:
        pUnit = &#39;ft&#39;
        pUnitXLocs = xLocs_FTinM
        pUnitYLocs = yLocs_FTinM
        pUnitXLabels = xLabelsFtEven
        pUnitYLabels = yLabelsFtEven
        
        sUnit = &#39;m&#39;
        sUnitXLocs = xlocsM
        sUnitYLocs = ylocsM
        sUnitXLabels = xlabelsM
        sUnitYLabels = ylabelsM
        __label_plot(fig, ax, gridM, gridFt, whichTicks, primaryUnit, pUnitXLocs, pUnitYLocs, pUnitXLabels,pUnitYLabels, sUnit, sUnitXLocs, sUnitYLocs, sUnitXLabels, sUnitYLabels, xLims=xLimsM, yLims=yLimsM, t=t)  
    
    else:
        pUnit = &#39;m&#39;
        pUnitXLocs = xlocsM
        pUnitYLocs = ylocsM
        pUnitXLabels = xlabelsM
        pUnitYLabels = ylabelsM

        sUnit = &#39;ft&#39;
        sUnitXLocs = xLocs_FTinM
        sUnitYLocs = yLocs_FTinM
        sUnitXLabels = xLabelsFtEven
        sUnitYLabels = yLabelsFtEven
        __label_plot(fig, ax, gridM, gridFt, whichTicks, primaryUnit, pUnitXLocs, pUnitYLocs, pUnitXLabels,pUnitYLabels, sUnit, sUnitXLocs, sUnitYLocs, sUnitXLabels, sUnitYLabels, xLims=xLimsM, yLims=yLimsM, t=t)
    
    if tight_layout:
        fig.tight_layout()
    else:
        plt.subplots_adjust(top=0.99, bottom=0.01, left=0.01, right=0.99, 
                    wspace=0, hspace=0)

    if cBarOrient==&#39;horizontal&#39;:
        aspect=50
    else:
        aspect=25
    cbar = fig.colorbar(im, ax=ax,orientation=cBarOrient, aspect=aspect, extend=&#39;both&#39;,ticks=cbarTicks,format=cBarFormat)
    cbar.ax.tick_params(labelsize=12)#set_ticks(cbarTicks)
    cbar.set_label(label=cBarLabel, size=16)

    ax_h, ax_w = ax.bbox.height, ax.bbox.width
    axRatio = ax_w/ax_h
    aspRatio = (xLimsM[1]-xLimsM[0])/(yLimsM[1]-yLimsM[0])
    vertExag = abs(round(aspRatio/axRatio, 1))
    iterNo = inv_dict[&#39;iterationNo&#39;]
    iterInd = inv_dict[&#39;iterationInd&#39;]
    iterErr = inv_dict[&#39;iterationDF&#39;].loc[iterInd, &#39;%AbsError&#39;]
    ax.annotate(&#39;Iteration {}\nRMS Error: {}%&#39;.format(iterNo, iterErr),xy=(0.02,0.02),xycoords=&#39;subfigure fraction&#39;, ha=&#39;left&#39;, va=&#39;bottom&#39;)
    ax.annotate(&#39;Vert.Exag: &#39;+str(vertExag)+&#39;x&#39;,xy=(0.98,0.02),xycoords=&#39;subfigure fraction&#39;, ha=&#39;right&#39;, va=&#39;bottom&#39;)
    fig.set_facecolor(&#34;w&#34;)

    return fig, ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="invplot.autoplot"><code class="name flex">
<span>def <span class="ident">autoplot</span></span>(<span>inv_file, iteration, return_dict=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to run all intermedaite functions and resinv_plot to simply read and plot everything in one call.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.PurePath object</code></dt>
<dd>Filepath to .inv file of interest. The .inv file should be one generated from Res2DInv.</dd>
<dt><strong><code>iteration</code></strong> :&ensp;<code>int</code> or <code>list</code> or <code>either str {':', 'all'}</code></dt>
<dd>Integer or list of integers indicating which iteration of the .inv result to use for plotting. If list, all will be plotted separately. If ':' or 'all', will plot all iterations successively.</dd>
<dt><strong><code>return_dict</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return results as a dictionary, by default False</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Other keyword arguments may be read into autoplot. These are read in as **kwargs to either resinv_plot() or matplotlib.pyplot.imshow via the resinv_plot function. See documentation for resinv_plot for available parameters for resinv_plot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all input parameters and data generated along the way, including the output figures and axes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoplot(inv_file, iteration, return_dict=False, **kwargs):
    &#34;&#34;&#34;Function to run all intermedaite functions and resinv_plot to simply read and plot everything in one call.

    Parameters
    ----------
    inv_file : str or pathlib.PurePath object
        Filepath to .inv file of interest. The .inv file should be one generated from Res2DInv.
    iteration : int or list or either str {&#39;:&#39;, &#39;all&#39;}
        Integer or list of integers indicating which iteration of the .inv result to use for plotting. If list, all will be plotted separately. If &#39;:&#39; or &#39;all&#39;, will plot all iterations successively.
    return_dict : bool, optional
        Whether to return results as a dictionary, by default False
    **kwargs
        Other keyword arguments may be read into autoplot. These are read in as **kwargs to either resinv_plot() or matplotlib.pyplot.imshow via the resinv_plot function. See documentation for resinv_plot for available parameters for resinv_plot.

    Returns
    -------
    inv_dict : dict
        Dictionary containing all input parameters and data generated along the way, including the output figures and axes

    &#34;&#34;&#34;
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)

    inv_dict = ingest_inv(inv_file, verbose=False, show_iterations=False)
    inv_dict = read_inv_data(inv_file=inv_file, inv_dict=inv_dict)

    allIterList = [&#39;:&#39;, &#39;all&#39;]
    if type(iteration) is int:
        iteration = [iteration]
    elif iteration.lower() in allIterList:
        iteration = inv_dict[&#39;iterationDF&#39;].Iteration.tolist()

    resinv_params_list = [&#39;inv_dict&#39;, &#39;colMap&#39;, &#39;cBarFormat&#39;, &#39;cBarLabel&#39;, &#39;cBarOrientation&#39;, &#39;cMin&#39;, &#39;cMax&#39;, 
                          &#39;griddedFt&#39;, &#39;griddedM&#39;, &#39;title&#39;, &#39;normType&#39;, &#39;primaryUnit&#39;, &#39;showPoints&#39;,&#39;whichTicks&#39;, 
                          &#39;figsize&#39;, &#39;dpi&#39;, &#39;reverse&#39;, &#39;tight_layout&#39;, &#39;savefig&#39;, &#39;saveformat&#39;]
    resinv_kwargs = {}
    imshow_kwargs = {}
    for key, value in kwargs.items():
        if key in resinv_params_list:
            resinv_kwargs[key] = value
        else:
            imshow_kwargs[key] = value

    iterIndList = []
    iterNoList = []
    figList = []
    axList = []

    for i in iteration:
        iterNo = i
        inv_dict[&#39;iterationNo&#39;] = iterNo
        iterInd = inv_dict[&#39;iterationDF&#39;][inv_dict[&#39;iterationDF&#39;].Iteration==i].index.tolist()[0]
        inv_dict[&#39;iterationInd&#39;] = iterInd
        inv_dict = read_inv_data_other(inv_file=inv_file, inv_dict=inv_dict, iteration_no=iterNo)
        inv_dict = read_error_data(inv_file=inv_file, inv_dict=inv_dict)
        inv_dict = get_resistivitiy_model(inv_file=inv_file, inv_dict=inv_dict)
        fig, ax = resinv_plot(inv_dict=inv_dict, imshow_kwargs=imshow_kwargs, **kwargs)

        iterIndList.append(i)
        iterNoList.append(inv_dict[&#39;iterationDF&#39;].loc[iterInd, &#39;Iteration&#39;])
        figList.append(fig)
        axList.append(ax)

    inv_dict[&#39;iterationNo&#39;] = iterIndList
    inv_dict[&#39;iterationInd&#39;] = iterNoList
    inv_dict[&#39;fig&#39;] = figList
    inv_dict[&#39;ax&#39;] = axList
    
    if return_dict:
        return inv_dict
    return</code></pre>
</details>
</dd>
<dt id="invplot.get_resistivitiy_model"><code class="name flex">
<span>def <span class="ident">get_resistivitiy_model</span></span>(<span>inv_file, inv_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read the resistivity model, given the iteration of interest.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath to .inv file of interest</dd>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing cumulative output from invest_inv, read_inv_data, read_inv_data_other, and read_error_data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary with resistivity model contained in new key:value pair of inv_dict</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resistivitiy_model(inv_file, inv_dict):
    &#34;&#34;&#34;Function to read the resistivity model, given the iteration of interest.

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest
    inv_dict : dict
        Dictionary containing cumulative output from invest_inv, read_inv_data, read_inv_data_other, and read_error_data.

    Returns
    -------
    dict
        Dictionary with resistivity model contained in new key:value pair of inv_dict
    &#34;&#34;&#34;
    resistModelDF = pd.DataFrame()
    layerRowList= inv_dict[&#39;layerRowList&#39;]
    iterationInd= inv_dict[&#39;iterationInd&#39;]
    layerDepths= inv_dict[&#39;layerDepths&#39;]
    noPoints= inv_dict[&#39;noPoints&#39;]
    electrodeCoordsDF= inv_dict[&#39;electrodeCoordsDF&#39;]
    topoDF= inv_dict[&#39;topoDF&#39;]

    for r in enumerate(layerRowList[iterationInd]):
        layerDepth = layerDepths[r[0]]
        noPtsInLyr = noPoints[r[0]]
        currDF = pd.read_table(inv_file, skiprows=r[1]+1, nrows=noPtsInLyr,sep=&#39;,&#39;)
        currDF.iloc[currDF.shape[0]-1,1] =  currDF.iloc[currDF.shape[0]-1,0]
        currDF.iloc[currDF.shape[0]-1,0] = currDF.iloc[currDF.shape[0]-2,0]+1
        currDF.columns=[&#39;ElectrodeNo&#39;,&#39;Data&#39;]
        currDF[&#39;zDepth&#39;] = layerDepth

        for i in currDF.index:
            lowerElecNo = currDF.loc[i,&#39;ElectrodeNo&#39;]#-1
            elecInd = electrodeCoordsDF.loc[electrodeCoordsDF[&#39;ElectrodeNo&#39;]==lowerElecNo].index.values[0]
            currDF.loc[i,&#39;x&#39;] = (electrodeCoordsDF.loc[elecInd,&#39;xDist&#39;] + electrodeCoordsDF.loc[elecInd+1,&#39;xDist&#39;])/2
            for xT in enumerate(topoDF[&#39;xDist&#39;]):
                if xT[1] &lt; currDF.loc[i,&#39;x&#39;]:
                    continue
                else:
                    topoX1 = topoDF.loc[xT[0]-1,&#39;xDist&#39;]
                    topoX2 = topoDF.loc[xT[0],&#39;xDist&#39;]
                    topoZ1 = topoDF.loc[xT[0]-1,&#39;Elevation&#39;]
                    topoZ2 = topoDF.loc[xT[0],&#39;Elevation&#39;]
                    break
            currDF.loc[i,&#39;zElev&#39;] = map_diff(currDF.loc[i,&#39;x&#39;],topoX1, topoX2, topoZ1, topoZ2)-currDF.loc[i,&#39;zDepth&#39;]
        if r[0] == 0:
            surfDF = currDF.copy()
            surfDF[&#39;zElev&#39;] = surfDF.loc[:,&#39;zElev&#39;]+surfDF.loc[:,&#39;zDepth&#39;]
            surfDF[&#39;zDepth&#39;] = 0
            resistModelDF = pd.concat([resistModelDF, surfDF], ignore_index=True)
            resistModelDF.reset_index(inplace=True, drop=True)
        resistModelDF = pd.concat([resistModelDF, currDF], ignore_index=True)
        resistModelDF.reset_index(inplace=True, drop=True)
    inv_dict[&#39;resistModelDF&#39;] = resistModelDF
    return inv_dict</code></pre>
</details>
</dd>
<dt id="invplot.ingest_inv"><code class="name flex">
<span>def <span class="ident">ingest_inv</span></span>(<span>inv_file, verbose=True, show_iterations=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to ingest inversion file and get key points (row numbers) in the file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>The res2Dinv .inv file to work with.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print results to terminal. Here, prints a pandas dataframe with information about iterations.</dd>
<dt><strong><code>show_iterations</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to show a matplotlib plot with the iteration on x axis and percent error on y axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing the important locations in the file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ingest_inv(inv_file, verbose=True, show_iterations=True):
    &#34;&#34;&#34;Function to ingest inversion file and get key points (row numbers) in the file

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        The res2Dinv .inv file to work with.
    verbose : bool, default=True
        Whether to print results to terminal. Here, prints a pandas dataframe with information about iterations.
    show_iterations : bool, default=True
        Whether to show a matplotlib plot with the iteration on x axis and percent error on y axis.

    Returns
    -------
    inv_dict : dict
        Dictionary containing the important locations in the file
    &#34;&#34;&#34;
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)
    
    fileHeader = []
    iterationStartRowList = []
    layerRowList = []
    layerDepths = []
    noLayerRow = -1
    blockRow = -1
    layerRow = -1
    layerInfoRow = -1
    resistDF = pd.DataFrame()
    dataList = []
    noPoints = []
    calcResistivityRowList = []
    refResistRow=-1
    topoDataRow = -1
    iterationsInfoRow = -1

    with open(str(inv_file)) as datafile: 
        filereader = csv.reader(datafile)
        for row in enumerate(filereader):
            startLayer = 0
            endLayer = 0
            lay = -1
            #print(row[0])
            if row[0] &lt;= 8:
               
                if len(row[1])&gt;1:
                    fileHeader.append(row[1][0]+&#39;, &#39;+row[1][1])
                    continue
                else:
                    fileHeader.append(row[1][0].strip())
                    continue
                
            if &#39;NUMBER OF LAYERS&#39; in str(row[1]):
                noLayerRow = row[0]+1
                continue
            if row[0] == noLayerRow:
                noLayers = int(row[1][0])
                layerList = np.linspace(1,noLayers, noLayers)
                continue
            
            if &#39;NUMBER OF BLOCKS&#39; in str(row[1]):
                blockRow = row[0]+1
                continue
            if row[0]==blockRow:
                noBlocks = int(row[1][0])
                continue

            if &#39;ITERATION&#39; in str(row[1]):
                iterationStartRowList.append(row[0]) #Add row of iteration to iterationStartRowList
                continue

            if &#39;LAYER &#39; in str(row[1]):
                iterInd = len(iterationStartRowList)-1
                if iterInd &gt; len(layerRowList)-1:
                    layerRowList.append([row[0]])
                else:
                    layerRowList[iterInd].append(row[0])
                layerInfoRow = row[0]+1
                continue
            if row[0]==layerInfoRow:
                noPoints.append(int(row[1][0].strip()))
                layerDepths.append(row[1][1].strip())
                continue
            
            if &#39;CALCULATED APPARENT RESISTIVITY&#39; in str(row[1]):
                calcResistivityRowList.append(row[0])
                continue
            
            if &#39;Reference resistivity is&#39; in str(row[1]):
                refResistRow = row[0]+1 
                continue
            
            if row[0]==refResistRow:
                refResist = float(row[1][0].strip())
                continue
            
            if &#39;TOPOGRAPHICAL DATA&#39; in str(row[1]):
                topoDataRow = row[0]
                continue
            if row[0]==topoDataRow+2:
                noTopoPts = int(row[1][0].strip())
                continue

            if &#39;COORDINATES FOR ELECTRODES&#39; in str(row[1]):
                electrodeCoordsRow = row[0]
                continue

            if &#39;Shift matrix&#39; in str(row[1]):
                shiftMatrixRow = row[0]
                continue

            if &#39;Blocks sensitivity and uncertainity values (with smoothness constrain)&#39; in str(row[1]):
                sensAndUncertainRow = row[0]
                continue

            if &#39;Error Distribution&#39; in str(row[1]):
                errorDistRow = row[0] #no of data points
                continue

            if &#39;Total Time&#39; in str(row[1]):
                iterationsInfoRow=row[0]
                iterDataList = []
                continue
            
            if iterationsInfoRow &gt; 1:
                if row[1] == []:
                    print(&#39;   &#39;)
                    noIterations = row[0]-iterationsInfoRow-1
                    break
                iterDataList.append(row[1][0].split())

    layerDepths = layerDepths[0:noLayers]
    layerDepths[noLayers-1] = float(layerDepths[(noLayers-2)])+(float(layerDepths[noLayers-2])-float(layerDepths[noLayers-3]))
    layerDepths = [float(x) for x in layerDepths]

    noPoints = noPoints[0:noLayers]

    keyList=[&#39;Name&#39;, &#39;NomElectrodeSpacing&#39;, &#39;ArrayCode&#39;, &#39;ProtocolCode&#39;, &#39;MeasureHeader&#39;, &#39;MeasureType&#39;, &#39;NoDataPoints&#39;,&#39;DistanceType&#39;,&#39;FinalFlag&#39;]

    global fileHeaderDict
    fileHeaderDict = dict(zip(keyList, fileHeader))
    noDataPoints = int(fileHeaderDict[&#39;NoDataPoints&#39;])
    iterationDF = pd.DataFrame(iterDataList, columns=[&#39;Iteration&#39;,  &#39;Time for this iteration&#39;, &#39;Total Time&#39;, &#39;%AbsError&#39;])
    iterationDF = iterationDF.apply(pd.to_numeric)

    if verbose:
        print(iterationDF)
    if show_iterations:
        fig1, ax1 = plt.subplots(1)
        iterationDF.plot(&#39;Iteration&#39;,&#39;%AbsError&#39;,figsize=(3,3), ax=ax1, c=&#39;k&#39;)
        iterationDF.plot(&#39;Iteration&#39;,&#39;%AbsError&#39;,figsize=(3,3),kind=&#39;scatter&#39;, ax=ax1, c=&#39;k&#39;)
        ax1.set_title(inv_file.stem)
        ax1.set_xticks(np.arange(0,iterationDF[&#39;Iteration&#39;].max()+1))
        ax1.get_legend().remove()
        plt.show(fig1)

    inv_dict = {
        &#39;inv_file_Path&#39;:inv_file,
        &#39;fileHeader&#39;:fileHeader,
        &#39;iterationStartRowList&#39;:iterationStartRowList,
        &#39;layerRowList&#39;:layerRowList, 
        &#39;layerDepths&#39;:layerDepths,
        &#39;noLayerRow&#39;:noLayerRow,
        &#39;blockRow&#39;:blockRow ,
        &#39;layerRow&#39;:layerRow ,
        &#39;layerInfoRow&#39;:layerInfoRow ,
        &#39;resistDF&#39;:resistDF,
        &#39;dataList&#39;:dataList,
        &#39;noPoints&#39;:noPoints,
        &#39;calcResistivityRowList&#39;:calcResistivityRowList ,
        &#39;refResistRow&#39;:refResistRow,
        &#39;topoDataRow&#39;:topoDataRow,
        &#39;iterationsInfoRow&#39;:iterationsInfoRow,
        &#39;iterationDF&#39;:iterationDF,
        &#39;noIterations&#39;:noIterations,
        &#39;noDataPoints&#39;:noDataPoints,
        &#39;shiftMatrixRow&#39;:shiftMatrixRow,
        &#39;electrodeCoordsRow&#39;:electrodeCoordsRow,
        &#39;noTopoPts&#39;:noTopoPts,
        &#39;sensAndUncertainRow&#39;:sensAndUncertainRow,
        &#39;noModelBlocks&#39;:[],
        &#39;errorDistRow&#39;:errorDistRow,
        &#39;fileHeaderDict&#39;:fileHeaderDict}
    
    return inv_dict</code></pre>
</details>
</dd>
<dt id="invplot.map_diff"><code class="name flex">
<span>def <span class="ident">map_diff</span></span>(<span>xIn, x1, x2, y1, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple, linear interpolation between two points</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xIn</code></strong> :&ensp;<code>float, int,</code> or <code>numeric</code></dt>
<dd>X Location at which y-value is desired. This should fall between (or be equal to) x1 and x2</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>float, int,</code> or <code>numeric</code></dt>
<dd>Initial X location, with known y-value y1</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float, int,</code> or <code>numeric</code></dt>
<dd>Second X location, with known y-value y2</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float, int,</code> or <code>numeric</code></dt>
<dd>Known y-value at x1</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float, int,</code> or <code>numeric</code></dt>
<dd>Known y-value at x2</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Y-value that is proportionally scaled based on the xIn relative distance to x1 and x2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_diff(xIn, x1,x2,y1,y2):
    &#34;&#34;&#34;Simple, linear interpolation between two points

    Parameters
    ----------
    xIn : float, int, or numeric
        X Location at which y-value is desired. This should fall between (or be equal to) x1 and x2
    x1 : float, int, or numeric
        Initial X location, with known y-value y1 
    x2 : float, int, or numeric
        Second X location, with known y-value y2
    y1 : float, int, or numeric
        Known y-value at x1
    y2 : float, int, or numeric
        Known y-value at x2

    Returns
    -------
    float
        Y-value that is proportionally scaled based on the xIn relative distance to x1 and x2
    &#34;&#34;&#34;
    if x1==xIn:
        yOut=y1
    elif x2==xIn:
        yOut = y2
    else:
        totXDiff = x2-x1
        percXDiff = (xIn-x1)/totXDiff
        totYDiff = y2-y1
        yOut = y1 + totYDiff*percXDiff
    return yOut</code></pre>
</details>
</dd>
<dt id="invplot.read_error_data"><code class="name flex">
<span>def <span class="ident">read_error_data</span></span>(<span>inv_file, inv_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read data pertaining to model error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath to .inv file of interest</dd>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict </code></dt>
<dd>Dictionary containing cumulative output from ingest_inv, read_inv_data, and read_inv_data_other</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Ouptput dictionary containing all information from read_error_data and previous functions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_error_data(inv_file, inv_dict):
    &#34;&#34;&#34;Function to read data pertaining to model error

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest
    inv_dict : dict 
        Dictionary containing cumulative output from ingest_inv, read_inv_data, and read_inv_data_other

    Returns
    -------
    dict
        Ouptput dictionary containing all information from read_error_data and previous functions.
    &#34;&#34;&#34;
    import csv
    noDataPoints = inv_dict[&#39;noDataPoints&#39;]
    startRow = inv_dict[&#39;errorDistRow&#39;]+1

    with open(inv_file) as datafile: 
        filereader = csv.reader(datafile)
        inDataList = []
        for row in enumerate(filereader):
            if row[0] &lt; startRow:
                continue
            elif row[0] &lt; startRow+noDataPoints:
                newrow = row[1]
                newrow.append(newrow[4][8:])
                newrow[4] = newrow[4][0:8]
                newrow = [x.strip() for x in newrow]
                inDataList.append(newrow)
            else:
                break
    inDF = pd.DataFrame(inDataList)
    inv_dict[&#39;errDistDF&#39;] = inDF

    errDistDF = inv_dict[&#39;errDistDF&#39;]

    colList=[&#39;xDist?&#39;,&#39;nFactor?&#39;,&#39;Measure1&#39;,&#39;Measure2&#39;,&#39;PercentError&#39;,&#39;MoreStacks&#39;,&#39;AvgMeasure&#39;]
    for i in range(0,5):
        errDistDF[i]=errDistDF[i].astype(np.float64)
        errDistDF.rename(columns={i:colList[i]},inplace=True)
    errDistDF[&#39;AvgMeasure&#39;] = (errDistDF[&#39;Measure1&#39;]+errDistDF[&#39;Measure2&#39;])/2
    inv_dict[&#39;errDistDF&#39;] = errDistDF
    return inv_dict</code></pre>
</details>
</dd>
<dt id="invplot.read_inv_data"><code class="name flex">
<span>def <span class="ident">read_inv_data</span></span>(<span>inv_file, inv_dict, startRow=9)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to do initial read of .inv file. </p>
<p>This data does not change with iteration, as in later function. This function should be readafter ingest_inv, using the output from that as inv_dict.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath of .inv file</dd>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary (output from ingest_inv) containing information about where data is located in the .inv file</dd>
<dt><strong><code>startRow</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Where to start the read. This is, by default 9, which works well for .inv files tested.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_inv_data(inv_file, inv_dict, startRow=9):
    &#34;&#34;&#34;Function to do initial read of .inv file. 
    
    This data does not change with iteration, as in later function. This function should be readafter ingest_inv, using the output from that as inv_dict.
     
    

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath of .inv file
    inv_dict : dict
        Dictionary (output from ingest_inv) containing information about where data is located in the .inv file
    startRow : int, optional
        Where to start the read. This is, by default 9, which works well for .inv files tested.

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    noDataPoints = inv_dict[&#39;noDataPoints&#39;]
    if isinstance(inv_file, pathlib.PurePath):
        pass
    else:
        inv_file = pathlib.Path(inv_file)

    import csv
    with open(inv_file) as datafile: 
        filereader = csv.reader(datafile)
        start = 0
        inDataList = []
        for row in enumerate(filereader):
            if row[0] &lt; startRow:
                continue
            elif row[0] &lt; startRow+noDataPoints:
                inDataList.append(re.sub(&#39;\s+&#39;,&#39; &#39;,row[1][0]).split(&#39; &#39;))
            else:
                break
    inDF = pd.DataFrame(inDataList)
    if startRow == 9:
        inDF.drop([0],inplace=True,axis=1)
    inDF.astype(np.float64)
    inDF.columns=[&#39;NoElectrodes&#39;, &#39;A(x)&#39;, &#39;A(z)&#39;, &#39;B(x)&#39;, &#39;B(z)&#39;, &#39;M(x)&#39;, &#39;M(z)&#39;, &#39;N(x)&#39;, &#39;N(z)&#39;, &#39;Data&#39;]
    inv_dict[&#39;resistDF&#39;]  = inDF
    return inv_dict</code></pre>
</details>
</dd>
<dt id="invplot.read_inv_data_other"><code class="name flex">
<span>def <span class="ident">read_inv_data_other</span></span>(<span>inv_file, inv_dict, iteration_no=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read inversion data. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_file</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath to .inv file of interest.</dd>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary contianing outputs from ingest_inv and read_in_data.</dd>
<dt><strong><code>iteration_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Iteration number of interest.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary with more information appended to input dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_inv_data_other(inv_file, inv_dict, iteration_no=None):
    &#34;&#34;&#34;Function to read inversion data. 

    Parameters
    ----------
    inv_file : str or pathlib.Path object
        Filepath to .inv file of interest.
    inv_dict : dict
        Dictionary contianing outputs from ingest_inv and read_in_data.
    iteration_no : int
        Iteration number of interest.

    Returns
    -------
    dict
        Dictionary with more information appended to input dictionary
    &#34;&#34;&#34;
    if iteration_no is None:
        print(&#39;Please run read_inv_data_other again and specify iteration by setting iteration_no parameter equal to integer.&#39;)
        return
    #Extract needed variables from dict
    iterationInd = inv_dict[&#39;iterationDF&#39;][inv_dict[&#39;iterationDF&#39;].Iteration==iteration_no].index.tolist()[0]
    inv_dict[&#39;iterationNo&#39;] = iteration_no
    inv_dict[&#39;iterationInd&#39;] = iterationInd


    invDF = inv_dict[&#39;resistDF&#39;]
    layerRowList = inv_dict[&#39;layerRowList&#39;]
    noPoints = inv_dict[&#39;noPoints&#39;]
    layerDepths = inv_dict[&#39;layerDepths&#39;]
    shiftMatrixRow = inv_dict[&#39;shiftMatrixRow&#39;]
    electrodeCoordsRow = inv_dict[&#39;electrodeCoordsRow&#39;]
    topoDataRow = inv_dict[&#39;topoDataRow&#39;]
    noTopoPts = inv_dict[&#39;noTopoPts&#39;]
    sensAndUncertainRow = inv_dict[&#39;sensAndUncertainRow&#39;]

    #Get Electrodes
    electrodes= pd.concat([invDF[&#39;A(x)&#39;],invDF[&#39;B(x)&#39;], invDF[&#39;M(x)&#39;], invDF[&#39;B(x)&#39;], invDF[&#39;N(x)&#39;]],ignore_index=True)
    electrodes.reset_index(inplace=True, drop=True)
    electrodes = electrodes.unique()
    inv_dict[&#39;electrodes&#39;] = electrodes

    #ElectrodeCoordinates
    noModelElects = shiftMatrixRow-electrodeCoordsRow-1
    electrodeCoordsDF = pd.read_table(inv_file,skiprows=electrodeCoordsRow,nrows=noModelElects, sep=&#39;\s+&#39;)
    electrodeCoordsDF.dropna(axis=1,inplace=True)
    electrodeCoordsDF.columns=[&#39;xDist&#39;,&#39;RelElevation&#39;]
    electrodeCoordsDF[&#39;ElectrodeNo&#39;] = electrodeCoordsDF.index+1
    inv_dict[&#39;electrodeCoordsDF&#39;] = electrodeCoordsDF

    #Topographical Data
    topoDF = pd.read_table(inv_file,skiprows=topoDataRow+2,nrows=noTopoPts, sep=&#39;\s+&#39;)
    topoDF.reset_index(inplace=True)
    topoDF.columns=[&#39;xDist&#39;,&#39;Elevation&#39;]
    topoDF[&#39;ElectrodeNo&#39;] = topoDF.index+1
    inv_dict[&#39;topoDF&#39;] = topoDF

    #Resistivity Model
    resistModelDF = pd.DataFrame()
    for r in enumerate(layerRowList[iterationInd]):
        layerDepth = layerDepths[r[0]]
        noPtsInLyr = noPoints[r[0]]
        currDF = pd.read_table(inv_file,skiprows=r[1]+1, nrows=noPtsInLyr,sep=&#39;,&#39;)
        currDF.columns=[&#39;ElectrodeNo&#39;,&#39;Data&#39;]
        currDF[&#39;z&#39;] = layerDepth
        resistModelDF= pd.concat([resistModelDF,currDF],ignore_index=True).copy()
    resistModelDF.reset_index(inplace=True, drop=True)
    noModelBlocks=resistModelDF.shape[0]
    inv_dict[&#39;resistModelDF&#39;] = resistModelDF
    inv_dict[&#39;noModelBlocks&#39;] = noModelBlocks

    #Shift Matrix
    shiftMatrixDF = pd.read_table(inv_file,skiprows=shiftMatrixRow+1,nrows=noModelElects, sep=&#39;\s+&#39;,header=None,index_col=0)
    shiftMatrixDF.dropna(axis=1,inplace=True)
    for c in shiftMatrixDF:
        shiftMatrixDF.rename(columns={c:&#39;Layer&#39;+str(int(c)-1)},inplace=True)
    inv_dict[&#39;shiftMatrixDF&#39;] = shiftMatrixDF

    #Sensitivity
    sensDF = pd.read_table(inv_file,skiprows=sensAndUncertainRow+3,nrows=noModelBlocks, sep=&#39;\s+&#39;,header=None,index_col=0)
    sensDF.dropna(axis=1,inplace=True)
    sensDF.reset_index(inplace=True)
    sensDF.columns=[&#39;BlockNo&#39;,&#39;Sensitivity&#39;, &#39;%ApproxUncertainty&#39;]
    inv_dict[&#39;sensDF&#39;] = sensDF

    return inv_dict</code></pre>
</details>
</dd>
<dt id="invplot.resinv_plot"><code class="name flex">
<span>def <span class="ident">resinv_plot</span></span>(<span>inv_dict, colMap='nipy_spectral', cBarFormat='%3.0f', cBarLabel='Resistivity (ohm-m)', cBarOrientation='horizontal', cMin=None, cMax=None, griddedFt=[False, False], griddedM=[False, False], title=None, normType='log', primaryUnit='m', showPoints=False, whichTicks='major', figsize=None, dpi=None, reverse=False, tight_layout=True, savefig=False, saveformat='png', imshow_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to pull everything together and plot it nicely.</p>
<p>It is recommended to use the autoplot function rather than resinv_plot directly, since using autoplot() incorporates all the setup needed to create the input dictionary keys/values correctly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of inversion results generated from previous steps</dd>
<dt><strong><code>colMap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Colormap, any acceptable from matplotlib, by default 'nipy_spectral'</dd>
<dt><strong><code>cBarFormat</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Format string for colorbar tick labels, by default '%3.0f'</dd>
<dt><strong><code>cBarLabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Colorbar label, by default 'Resistivity (ohm-m)'</dd>
<dt><strong><code>cBarOrientation</code></strong> :&ensp;<code>str {'horizonta', 'vertical'}</code>, optional</dt>
<dd>Orientation of the colorbar, by default 'horizontal'</dd>
<dt><strong><code>cMin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Minimum of colorbar/colormap, by default None, which uses the minimum value of the dataset.</dd>
<dt><strong><code>cMax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum of colorbar/colormap, by default None, which uses the maximum value of the dataset.</dd>
<dt><strong><code>griddedFt</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Whether to show gridlines on the feet ticks, first position is x, second position is y, by default [False,False]</dd>
<dt><strong><code>griddedM</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Whether to show gridlines on the meter tickes, first position is x, second posistion is y, by default [False,False]</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>String to show as the title, if desired to set manually, by default None, which shows the filename as the title</dd>
<dt><strong><code>normType</code></strong> :&ensp;<code>str {'log', 'linear'}</code>, optional</dt>
<dd>Normalization type, by default 'log'. Determines whether matplotlib.colors.LogNorm or matplotlib.colors.Normalize is used for colormap.</dd>
<dt><strong><code>primaryUnit</code></strong> :&ensp;<code>str {'m', 'ft'}</code>, optional</dt>
<dd>Whether to display meters or feet as primary unit (this determines which unit is larger on the axis and is on the left and top), by default 'm'</dd>
<dt><strong><code>showPoints</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the datapoints used for interpolation, by default False</dd>
<dt><strong><code>whichTicks</code></strong> :&ensp;<code>str {'major', 'minor', 'both'}</code>, optional</dt>
<dd>If griddedFt or griddedM has any True, this determines whether major, minor, or both gridlines are used; by default 'major'.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Tuple (width, height) of the figsize, read into plt.rcParams['figure.figsize'], by default None.</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Resolution (dots per square inch) of final figure, read into plt.rcParams['figure.dpi'], by default None.</dd>
<dt><strong><code>reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to display the data in reverse (flipped along x) of what is read into from .inv file, by default False</dd>
<dt><strong><code>tight_layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, calls fig.tight_layout(). Otherwise, tries to maximize space on the figure using plt.subplots_adjust, by default True</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False, will not save figure. Otherwise, calls plt.savefig() and the value of this parameter will be used as the output filepath, by default False.</dd>
<dt><strong><code>saveformat</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Read into plt.savefig(format) paramater, by default 'png'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Returns existing inv_dict input, but with added keys of ['fig'] and ['ax'] containing a list of the fig and ax objects (list, since multiple iterations can be done at once)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resinv_plot(inv_dict, colMap=&#39;nipy_spectral&#39;, cBarFormat =&#39;%3.0f&#39;, cBarLabel=&#39;Resistivity (ohm-m)&#39;, cBarOrientation=&#39;horizontal&#39;, cMin=None, cMax=None, griddedFt=[False,False], griddedM=[False,False], title=None, normType=&#39;log&#39;, primaryUnit=&#39;m&#39;, showPoints=False,whichTicks=&#39;major&#39;, figsize=None, dpi=None, reverse=False, tight_layout=True, savefig=False, saveformat=&#39;png&#39;, imshow_kwargs=None, **kwargs):
    &#34;&#34;&#34;Function to pull everything together and plot it nicely.

    It is recommended to use the autoplot function rather than resinv_plot directly, since using autoplot() incorporates all the setup needed to create the input dictionary keys/values correctly.

    Parameters
    ----------
    inv_dict : dict
        Dictionary of inversion results generated from previous steps
    colMap : str, optional
        Colormap, any acceptable from matplotlib, by default &#39;nipy_spectral&#39;
    cBarFormat : str, optional
        Format string for colorbar tick labels, by default &#39;%3.0f&#39;
    cBarLabel : str, optional
        Colorbar label, by default &#39;Resistivity (ohm-m)&#39;
    cBarOrientation : str {&#39;horizonta&#39;, &#39;vertical&#39;}, optional
        Orientation of the colorbar, by default &#39;horizontal&#39;
    cMin : float, optional
        Minimum of colorbar/colormap, by default None, which uses the minimum value of the dataset.
    cMax : float, optional
        Maximum of colorbar/colormap, by default None, which uses the maximum value of the dataset.
    griddedFt : list, optional
        Whether to show gridlines on the feet ticks, first position is x, second position is y, by default [False,False]
    griddedM : list, optional
        Whether to show gridlines on the meter tickes, first position is x, second posistion is y, by default [False,False]
    title : str, optional
        String to show as the title, if desired to set manually, by default None, which shows the filename as the title
    normType : str {&#39;log&#39;, &#39;linear&#39;}, optional
        Normalization type, by default &#39;log&#39;. Determines whether matplotlib.colors.LogNorm or matplotlib.colors.Normalize is used for colormap.
    primaryUnit : str {&#39;m&#39;, &#39;ft&#39;}, optional
        Whether to display meters or feet as primary unit (this determines which unit is larger on the axis and is on the left and top), by default &#39;m&#39;
    showPoints : bool, optional
        Whether to show the datapoints used for interpolation, by default False
    whichTicks : str {&#39;major&#39;, &#39;minor&#39;, &#39;both&#39;}, optional
        If griddedFt or griddedM has any True, this determines whether major, minor, or both gridlines are used; by default &#39;major&#39;.
    figsize : tuple, optional
        Tuple (width, height) of the figsize, read into plt.rcParams[&#39;figure.figsize&#39;], by default None.
    dpi : int or float, optional
        Resolution (dots per square inch) of final figure, read into plt.rcParams[&#39;figure.dpi&#39;], by default None.
    reverse : bool, optional
        Whether to display the data in reverse (flipped along x) of what is read into from .inv file, by default False
    tight_layout : bool, optional
        If true, calls fig.tight_layout(). Otherwise, tries to maximize space on the figure using plt.subplots_adjust, by default True
    savefig : bool, optional
        If False, will not save figure. Otherwise, calls plt.savefig() and the value of this parameter will be used as the output filepath, by default False.
    saveformat : str, optional
        Read into plt.savefig(format) paramater, by default &#39;png&#39;.

    Returns
    -------
    dict
        Returns existing inv_dict input, but with added keys of [&#39;fig&#39;] and [&#39;ax&#39;] containing a list of the fig and ax objects (list, since multiple iterations can be done at once)
    &#34;&#34;&#34;
    if title is None:
        title = inv_dict[&#39;inv_file_Path&#39;].stem
    
    if &#39;figure.dpi&#39; not in list(inv_dict.keys()):
        inv_dict[&#39;figure.dpi&#39;] = 250
    if &#39;figure.figsize&#39; not in list(inv_dict.keys()):
        inv_dict[&#39;figure.figsize&#39;] = (12,5)

    x = inv_dict[&#39;resistModelDF&#39;][&#39;x&#39;].copy()
    z = inv_dict[&#39;resistModelDF&#39;][&#39;zElev&#39;].copy()
    v = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].copy()

    if figsize is None:
        plt.rcParams[&#39;figure.figsize&#39;] = inv_dict[&#39;figure.figsize&#39;]
    else:
        inv_dict[&#39;figure.figsize&#39;] = figsize
        plt.rcParams[&#39;figure.figsize&#39;] = figsize

    if dpi is None:
        plt.rcParams[&#39;figure.dpi&#39;] = inv_dict[&#39;figure.dpi&#39;]
    else:
        inv_dict[&#39;figure.dpi&#39;] = dpi
        plt.rcParams[&#39;figure.dpi&#39;] = dpi
    
    maxXDist = max(np.float_(inv_dict[&#39;electrodes&#39;]))

    if cMin is None:
        cMin = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].min()
    if cMax is None:
        cMax = inv_dict[&#39;resistModelDF&#39;][&#39;Data&#39;].max()
    

    for i in enumerate(v):
        v[i[0]] = abs(float(i[1]))

    xi, zi = np.linspace(min(x), max(x), int(max(x))), np.linspace(min(z), max(z), int(max(z)))
    xi, zi = np.meshgrid(xi, zi)

    vi = scipy.interpolate.griddata((x, z), v, (xi, zi))#, method=&#39;linear&#39;)

    ptSize = round(100 / maxXDist * 35, 1)

    fig, axes = plt.subplots(1)
    cmap = matplotlib.cm.binary
    my_cmap = cmap(np.arange(cmap.N))
    my_cmap[:,-1] = np.linspace(0,1,cmap.N)
    my_cmap = matplotlib.colors.ListedColormap(my_cmap)

    vmax98 = np.percentile(v, 98)
    vmin2 = np.percentile(v, 2)
    minx = min(x)
    maxx = max(x)
    minz = min(z)
    maxz = max(z)

    vmax = cMax
    vmin = cMin

    #if cMax &gt;= resistModelDF[&#39;Data&#39;].max():
    #  vmax = vmax98
    #else:
    #  vmax = cMax
    #if cMin &lt;= resistModelDF[&#39;Data&#39;].min():
    #  vmin = vmin2
    #else:
    #  vmin = cMin
    #cbarTicks = np.arange(np.round(vmin,-1),np.round(vmax-1)+1,10) 

    arStep = np.round((vmax-vmin)/10,-1)
    cbarTicks = np.arange(np.round(vmin, -1), np.ceil(vmax/10)*10,arStep)

    #Get default values or kwargs, depending on if kwargs have been used
    if &#39;norm&#39; in imshow_kwargs.keys():
        norm = imshow_kwargs[&#39;norm&#39;]
    else:
        if normType==&#39;log&#39;:
            if vmin &lt;= 0:
                vmin = 0.1
            norm = matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax)
            #cBarFormat = &#39;%.1e&#39;
            #cbarTicks = np.logspace(np.log10(vmin),np.log10(vmax),num=10)
        else:
            norm = matplotlib.colors.Normalize(vmin = vmin, vmax = vmax)

    #im = self.axes.imshow(vi, vmin=vmin, vmax=vmax, origin=&#39;lower&#39;,
    if &#39;extent&#39; in imshow_kwargs.keys():
        extent = imshow_kwargs[&#39;extent&#39;]
        imshow_kwargs.pop(&#39;extent&#39;, None)
    else:
        extent = [minx, maxx, minz, maxz]
        
    if &#39;aspect&#39; in imshow_kwargs.keys():
        aspect = imshow_kwargs[&#39;aspect&#39;]
        imshow_kwargs.pop(&#39;aspect&#39;, None)
    else:
        aspect = &#39;auto&#39;
        
    if &#39;cmap&#39; in imshow_kwargs.keys():
        cmap = imshow_kwargs[&#39;cmap&#39;]
        imshow_kwargs.pop(&#39;cmap&#39;, None)
    else:
        cmap=colMap   
        
    if &#39;interpolation&#39; in imshow_kwargs.keys():
        interp = imshow_kwargs[&#39;interpolation&#39;]
        imshow_kwargs.pop(&#39;interpolation&#39;, None)
    else:
        interp=&#39;spline36&#39;   
    
    im = axes.imshow(vi, origin=&#39;lower&#39;,
                extent=extent,
                aspect=aspect,
                cmap =cmap,
                norm = norm,
                interpolation=interp, **imshow_kwargs)
    f, a = __plot_pretty(inv_dict, x,z,v,fig=fig,im=im,ax=axes,colMap=colMap,cMin=cMin,cMax=cMax, 
                       gridM=griddedM, gridFt=griddedFt, primaryUnit=primaryUnit, t=title, tight_layout=tight_layout,
                       cbarTicks=cbarTicks,cBarFormat=cBarFormat,cBarLabel=cBarLabel,cBarOrient=cBarOrientation,
                       showPoints=showPoints, norm=norm, whichTicks=whichTicks, reverse=reverse)

    plt.show(fig)
    if savefig is not False:
        plt.savefig(savefig, format=saveformat, facecolor=&#39;white&#39;)

    plt.close(f)
    return f, a</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="invplot.autoplot" href="#invplot.autoplot">autoplot</a></code></li>
<li><code><a title="invplot.get_resistivitiy_model" href="#invplot.get_resistivitiy_model">get_resistivitiy_model</a></code></li>
<li><code><a title="invplot.ingest_inv" href="#invplot.ingest_inv">ingest_inv</a></code></li>
<li><code><a title="invplot.map_diff" href="#invplot.map_diff">map_diff</a></code></li>
<li><code><a title="invplot.read_error_data" href="#invplot.read_error_data">read_error_data</a></code></li>
<li><code><a title="invplot.read_inv_data" href="#invplot.read_inv_data">read_inv_data</a></code></li>
<li><code><a title="invplot.read_inv_data_other" href="#invplot.read_inv_data_other">read_inv_data_other</a></code></li>
<li><code><a title="invplot.resinv_plot" href="#invplot.resinv_plot">resinv_plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>